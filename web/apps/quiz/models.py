# Django core
from django.conf import settings
from django.contrib.postgres.fields import ArrayField
from django.db import models
from django.utils import timezone

# Our apps
from apps.studio.blocks.models import Block
from apps.lms.results.models import BlockResult


# All lessons contains blocks (text, choice, question with float answer)
class Quiz(models.Model):
    # creator of quiz (can be teacher or user if autogenerated)
    # owner = models.ForeignKey(User, on_delete=models.CASCADE, related_name='quizzes')

    # tags

    title = models.CharField(
        verbose_name="Заголовок",
        max_length=60,
        blank=False
    )

    blocks_ids = ArrayField(
        models.IntegerField(),
        verbose_name='Массив из id блоков',
        blank=True
    )

    description = models.TextField(
        verbose_name="Описание",
        blank=False
    )

    single_attempt = models.BooleanField(
        blank=False,
        default=False,
        verbose_name="Single Attempt"
    )

    # random_order = models.BooleanField(blank=False, default=False, verbose_name=_("Random Order"), help_text=_("Display the questions in a random order or as they are set?"))

    # answers_at_end = models.BooleanField(blank=False, default=False, help_text=_("Correct answer is NOT shown after question. Answers displayed at the end."), verbose_name=_("Answers at end"))

    # pass_mark = models.SmallIntegerField(blank=True, default=0, verbose_name=_("Pass Mark"), help_text=_("Percentage required to pass exam."), validators=[MaxValueValidator(100)])

    # success_text = models.TextField( blank=True, help_text=_("Displayed if user passes."), verbose_name=_("Success Text"))

    # fail_text = models.TextField(verbose_name=_("Fail Text"), blank=True, help_text=_("Displayed if user fails."))

    # draft = models.BooleanField(blank=True, default=False, verbose_name=_("Draft"), help_text=_("If yes, the quiz is not displayed in the quiz list and can only be taken by users who can edit quizzes."))

    class Meta:
        verbose_name = 'тест'
        verbose_name_plural = 'тесты'

    def __str__(self):
        return self.title

    def get_absolute_url(self):
        from django.urls import reverse
        return reverse('quiz', args=[str(self.pk)])


# Manager for quiz progress
# Provide methods for get or create user progress
class QuizProgressManager(models.Manager):

    # Create new progress contains blocks order
    def new_progress(self, user, quiz):

        new_progress = self.create(
            user=user,
            quiz=quiz,
            blocks_order=quiz.blocks_ids,
        )
        return new_progress

    # Get or create method
    def user_progress(self, user, quiz):
        # if single attempt is already taken - get complete QuizProgress
        if quiz.single_attempt is True and self.filter(user=user,
                                                       quiz=quiz,
                                                       complete=True).exists():
            return self.filter(user=user, quiz=quiz, complete=True).order_by('end_time')[0]

        try:
            progress = self.get(user=user, quiz=quiz, complete=False)
        except QuizProgress.DoesNotExist:
            progress = self.new_progress(user, quiz)
        except QuizProgress.MultipleObjectsReturned:
            progress = self.filter(user=user, quiz=quiz, complete=False).order_by('end_time')[0]
        return progress


# TODO: quiz progress may be a task analog
class QuizProgress(models.Model):
    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        verbose_name=u'Ученик',
        on_delete=models.CASCADE
    )

    quiz = models.ForeignKey(
        Quiz,
        verbose_name="Тест",
        on_delete=models.CASCADE
    )

    # blocks_order is a list of integer pks of all the questions in the quiz, in order.
    blocks_order = ArrayField(
        models.IntegerField(),
        verbose_name='Порядок блоков',
        blank=True
    )

    # Current block pointer like blocks_order[current_block_index]
    # May be blank if quiz is just started
    current_block_index = models.SmallIntegerField(
        default=0,
        verbose_name="Индекс текущего блока"
    )

    # pass_mark = models.SmallIntegerField(blank=True, default=0, verbose_name=_("Pass Mark"), help_text=_("Percentage required to pass exam."), validators=[MaxValueValidator(100)])

    complete = models.BooleanField(
        default=False,
        blank=False,
        verbose_name="Закончен"
    )

    start_time = models.DateTimeField(default=timezone.now, verbose_name="Start")

    end_time = models.DateTimeField(null=True, blank=True, verbose_name="End")

    complete_score = models.IntegerField(verbose_name="Complete Calculated Score", blank=True, default=0)

    max_score = models.IntegerField(verbose_name="Max Score", blank=True, default=0)

    objects = QuizProgressManager()

    class Meta:
        verbose_name = 'прогресс теста'
        verbose_name_plural = 'прогрессы тестов'

    def __str__(self):
        return u'Quiz progress #{}'.format(self.id)

    def get_absolute_url(self):
        from django.urls import reverse
        return reverse('quiz', args=[str(self.quiz.pk)])

    def get_next_block(self):
        """
        Returns the next block.
        If no block is found, returns False
        If test is just started returns False also
        """
        if not self.blocks_order:
            return False

        block_id = int(self.blocks_order[self.current_block_index])
        return Block.objects.get_subclass(pk=block_id)

    def get_percent_finished(self):
        """
        Returns the percent of already taken blocks
        """
        return int(float(self.current_block_index) / len(self.blocks_order) * 100)

    def go_to_next_block(self):
        """
        +1 pointer to current block
        If it not exist, set complete flag and reset pointer
        """
        self.current_block_index += 1
        if self.current_block_index == len(self.blocks_order):
            self.complete = True
            now = timezone.now()
            self.end_time = now
            self.save()
            self.calculate_score()
        else:
            self.save()

    def calculate_score(self):
        """
        Calculate score on complete quiz
        For avoid db requests to results
        """
        if self.complete:
            results = self.get_blocks_results()
            max_score_total = 0
            score_total = 0

            for result in results:
                max_score_total += result.max_score
                score_total += result.score

            self.max_score = max_score_total
            self.complete_score = score_total
            self.save()

    def get_percent_correct(self):
        if self.complete_score != 0:
            return int(round((float(self.complete_score) / self.max_score) * 100))
        else:
            return False

    def get_blocks_results(self):
        # avoid no end_time problem for incomplete progress
        if self.end_time:
            end_time = self.end_time
        else:
            end_time = timezone.now()

        results = BlockResult.objects.filter(
            date__gte=self.start_time,
            date__lte=end_time,
            user=self.user
        ).select_subclasses()

        return results
